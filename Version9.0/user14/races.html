<!DOCTYPE html>
<html lang="en">
<!--Version 3.0
        Name:Tate Hartmann
        Date Completed:
    -->

<head>
    <link rel='icon' href='images/favicon.ico' type='image/x-icon' />
    <link href="CSS/night.css" rel="stylesheet">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="SHS WebDev Menu Sample">

    <title>Races</title>

    <!-- Bootstrap core JS -->
    <!-- These are needed to get the responsive menu to work -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"></script>

    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

    <!-- Custom styles for this template -->
    <style type="text/css">
        .menu {
            margin: 0px;
        }

        .wideMargin {
            margin: 15px;
        }


        #footer {
            font-size: 12px;
            text-align: center;
        }

        canvas {
            border: 1px solid white;
        }

        }

    </style>
</head>

<body>
    <div class="menu">
        <nav class="navbar navbar-expand-md navbar-dark bg-dark">
            <a href="http://shakonet.isd720.com" class="navbar-brand">DND</a>
            <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbarCollapse">
                <span class="navbar-toggler-icon"></span>
            </button>

            <div class="collapse navbar-collapse" id="navbarCollapse">
                <div class="navbar-nav">
                    <!---------------------------------- Edit These Items in your Menu ------------->
                    <a href="index.html" class="nav-item nav-link">Home</a>
                    <a href="dice.php" class="nav-item nav-link">Dice</a>
                    <a href="classes.html" class="nav-item nav-link" tabindex="-1">Classes</a>
                    <a href="#" class="nav-item nav-link active" tabindex="-2">Races</a>
                    
                    <a href="characters.php" class="nav-item nav-link" tabindex="-2">Characters</a>
                    
                    <a href="faq.php" class="nav-item nav-link" tabindex="-2">FAQ</a>
                    <a href="contact.html" class="nav-item nav-link" tabindex="-2">Contact</a>
                    <!----------------------------------^ Edit These Items in your Menu ^ ------------->
                </div>
                <div class="navbar-nav ml-auto">

                </div>
            </div>
        </nav>
    </div>


    <body>
        <h1 class="wideMargin">Races</h1>
        <div class="wideMargin">
            <p>
                <h2>Dragonborn (PHB)</h2>
        </div>
        Str +2
        Cha +1

        Descendants of dragons, these draconic humanoids live in clans who they value more than their life itself. Depending on their color, they get a breath attack of a specific type, as well as resistance to that same type of damage in combat. They tend to be as strong as they are charismatic, just like their fellow ancestors. Even though they are covered in scales, they lack the tail and wings that make dragons so characteristic.</p><br />
        <p>
            <h2>Dwarf (PHB)</h2>
            Con +2

            Stout, short and hardworking. Those might be the best words to describe a dwarf. Having their race forged by the god Moradin, they were taught of the benefits of hard labor, perfection in their works, and the importance of their clans. Dwarves live their long lives with a spirit of good and justice, that may only be corrupted by greed. Their sturdiness allows them to be more resistant than other classes in combat as well as resist poison. They tend to vary depending of the place they are from.
        </p><br />
        <p>
            <h2>Elf (PHB)</h2>
            Dex+2

            Elves are magical and gracious beings, as well as very close to being eternal. They develop many different attitudes during their life. When young (young being up to 100 years old) they have an adventurous and curious way of thought, making them go for adventures. By the time they reach adulthood their personalities change and become much more peaceful, but don’t discard the idea of going exploring until they become elders. They make for excellent artists and tend to be quite chaotic when it comes to laws. Last but not least, they don’t sleep but enter trances for 4 hours a day in which they remain semiconscious.
        </p><br />
        <p>
            <h2>Gnome (PHB)</h2>
            Int+2

            Gnomes are weird super positive beings. Their spirits shine even in the darkest nights. Great inventors, pranksters, and even better intellectuals. Living away from other communities they tend to live pretty normal lives in their about 500 years. However, just like halflings, curiosity is something that every one of them carries, as well as their impulsive behavior, creating excellent and many adventurers out of them.

        </p><br />
        <p>
            <h2>Halfling (PHB)</h2>
            Dex+2

            Halflings are isolated, cheerful people who love the commodity of their homes and communities. That’s the main reason most of them don’t abandon their birthplaces (shires). However, a strong sense of curiosity inhabits in most of them, leading these little folk to become adventurers or travel to other places. They are extremely agile, but as a result of their short legs, not as fast as the other races
        </p> <br />
        <p>
            <h2>Human (PHB)</h2>
            All+1

            Well… I suppose you are a human, so you should know what we are good at. Absolutely nothing! Or more precisely, a bit in everything. Humans are quite more anxious and eager to adventure than the other races due to their short lives (in comparison with the others).
        </p><br />
        <p>
            <h2>Tiefling (PHB)</h2>
            Int+1
            Cha+2

            Tieflings take lots of forms and colors. They can have different kinds of horns and tails, as well as be from a great variety of colors. Nevertheless, they share some kind of curse. These are beings of infernal lineage due to a pact that someone in the long past made with Asmodeus (lord of Hell). They look mostly human, not taking into account the features described above. Even though they are mostly intellectual and highly charismatic beings, they tend to be received with mistrust by superstitious people.
        </p> <br />

        <div class="wideMargin" id="footer">
            <p>

                Webpage made with love.
            </p>
        </div>



        </div>
        <div style="background-color: black">
            <canvas width="320" height="640" id="game"></canvas>
            <script>
                // https://tetris.fandom.com/wiki/Tetris_Guideline

                // get a random integer between the range of [min,max]
                // @see https://stackoverflow.com/a/1527820/2124254
                function getRandomInt(min, max) {
                    min = Math.ceil(min);
                    max = Math.floor(max);

                    return Math.floor(Math.random() * (max - min + 1)) + min;
                }

                // generate a new tetromino sequence
                // @see https://tetris.fandom.com/wiki/Random_Generator
                function generateSequence() {
                    const sequence = ['I', 'J', 'L', 'O', 'S', 'T', 'Z'];

                    while (sequence.length) {
                        const rand = getRandomInt(0, sequence.length - 1);
                        const name = sequence.splice(rand, 1)[0];
                        tetrominoSequence.push(name);
                    }
                }

                // get the next tetromino in the sequence
                function getNextTetromino() {
                    if (tetrominoSequence.length === 0) {
                        generateSequence();
                    }

                    const name = tetrominoSequence.pop();
                    const matrix = tetrominos[name];

                    // I and O start centered, all others start in left-middle
                    const col = playfield[0].length / 2 - Math.ceil(matrix[0].length / 2);

                    // I starts on row 21 (-1), all others start on row 22 (-2)
                    const row = name === 'I' ? -1 : -2;

                    return {
                        name: name, // name of the piece (L, O, etc.)
                        matrix: matrix, // the current rotation matrix
                        row: row, // current row (starts offscreen)
                        col: col // current col
                    };
                }

                // rotate an NxN matrix 90deg
                // @see https://codereview.stackexchange.com/a/186834
                function rotate(matrix) {
                    const N = matrix.length - 1;
                    const result = matrix.map((row, i) =>
                        row.map((val, j) => matrix[N - j][i])
                    );

                    return result;
                }

                // check to see if the new matrix/row/col is valid
                function isValidMove(matrix, cellRow, cellCol) {
                    for (let row = 0; row < matrix.length; row++) {
                        for (let col = 0; col < matrix[row].length; col++) {
                            if (matrix[row][col] && (
                                    // outside the game bounds
                                    cellCol + col < 0 ||
                                    cellCol + col >= playfield[0].length ||
                                    cellRow + row >= playfield.length ||
                                    // collides with another piece
                                    playfield[cellRow + row][cellCol + col])) {
                                return false;
                            }
                        }
                    }

                    return true;
                }

                // place the tetromino on the playfield
                function placeTetromino() {
                    for (let row = 0; row < tetromino.matrix.length; row++) {
                        for (let col = 0; col < tetromino.matrix[row].length; col++) {
                            if (tetromino.matrix[row][col]) {

                                // game over if piece has any part offscreen
                                if (tetromino.row + row < 0) {
                                    return showGameOver();
                                }

                                playfield[tetromino.row + row][tetromino.col + col] = tetromino.name;
                            }
                        }
                    }

                    // check for line clears starting from the bottom and working our way up
                    for (let row = playfield.length - 1; row >= 0;) {
                        if (playfield[row].every(cell => !!cell)) {

                            // drop every row above this one
                            for (let r = row; r >= 0; r--) {
                                for (let c = 0; c < playfield[r].length; c++) {
                                    playfield[r][c] = playfield[r - 1][c];
                                }
                            }
                        } else {
                            row--;
                        }
                    }

                    tetromino = getNextTetromino();
                }

                // show the game over screen
                function showGameOver() {
                    cancelAnimationFrame(rAF);
                    gameOver = true;

                    context.fillStyle = 'black';
                    context.globalAlpha = 0.75;
                    context.fillRect(0, canvas.height / 2 - 30, canvas.width, 60);

                    context.globalAlpha = 1;
                    context.fillStyle = 'white';
                    context.font = '36px monospace';
                    context.textAlign = 'center';
                    context.textBaseline = 'middle';
                    context.fillText('GAME OVER!', canvas.width / 2, canvas.height / 2);
                }

                const canvas = document.getElementById('game');
                const context = canvas.getContext('2d');
                const grid = 32;
                const tetrominoSequence = [];

                // keep track of what is in every cell of the game using a 2d array
                // tetris playfield is 10x20, with a few rows offscreen
                const playfield = [];

                // populate the empty state
                for (let row = -2; row < 20; row++) {
                    playfield[row] = [];

                    for (let col = 0; col < 10; col++) {
                        playfield[row][col] = 0;
                    }
                }

                // how to draw each tetromino
                // @see https://tetris.fandom.com/wiki/SRS
                const tetrominos = {
                    'I': [
                        [0, 0, 0, 0],
                        [1, 1, 1, 1],
                        [0, 0, 0, 0],
                        [0, 0, 0, 0]
                    ],
                    'J': [
                        [1, 0, 0],
                        [1, 1, 1],
                        [0, 0, 0],
                    ],
                    'L': [
                        [0, 0, 1],
                        [1, 1, 1],
                        [0, 0, 0],
                    ],
                    'O': [
                        [1, 1],
                        [1, 1],
                    ],
                    'S': [
                        [0, 1, 1],
                        [1, 1, 0],
                        [0, 0, 0],
                    ],
                    'Z': [
                        [1, 1, 0],
                        [0, 1, 1],
                        [0, 0, 0],
                    ],
                    'T': [
                        [0, 1, 0],
                        [1, 1, 1],
                        [0, 0, 0],
                    ]
                };

                // color of each tetromino
                const colors = {
                    'I': 'cyan',
                    'O': 'yellow',
                    'T': 'purple',
                    'S': 'green',
                    'Z': 'red',
                    'J': 'blue',
                    'L': 'orange'
                };

                let count = 0;
                let tetromino = getNextTetromino();
                let rAF = null; // keep track of the animation frame so we can cancel it
                let gameOver = false;

                // game loop
                function loop() {
                    rAF = requestAnimationFrame(loop);
                    context.clearRect(0, 0, canvas.width, canvas.height);

                    // draw the playfield
                    for (let row = 0; row < 20; row++) {
                        for (let col = 0; col < 10; col++) {
                            if (playfield[row][col]) {
                                const name = playfield[row][col];
                                context.fillStyle = colors[name];

                                // drawing 1 px smaller than the grid creates a grid effect
                                context.fillRect(col * grid, row * grid, grid - 1, grid - 1);
                            }
                        }
                    }

                    // draw the active tetromino
                    if (tetromino) {

                        // tetromino falls every 35 frames
                        if (++count > 35) {
                            tetromino.row++;
                            count = 0;

                            // place piece if it runs into anything
                            if (!isValidMove(tetromino.matrix, tetromino.row, tetromino.col)) {
                                tetromino.row--;
                                placeTetromino();
                            }
                        }

                        context.fillStyle = colors[tetromino.name];

                        for (let row = 0; row < tetromino.matrix.length; row++) {
                            for (let col = 0; col < tetromino.matrix[row].length; col++) {
                                if (tetromino.matrix[row][col]) {

                                    // drawing 1 px smaller than the grid creates a grid effect
                                    context.fillRect((tetromino.col + col) * grid, (tetromino.row + row) * grid, grid - 1, grid - 1);
                                }
                            }
                        }
                    }
                }

                // listen to keyboard events to move the active tetromino
                document.addEventListener('keydown', function(e) {
                    if (gameOver) return;

                    // left and right arrow keys (move)
                    if (e.which === 37 || e.which === 39) {
                        const col = e.which === 37 ?
                            tetromino.col - 1 :
                            tetromino.col + 1;

                        if (isValidMove(tetromino.matrix, tetromino.row, col)) {
                            tetromino.col = col;
                        }
                    }

                    // up arrow key (rotate)
                    if (e.which === 38) {
                        const matrix = rotate(tetromino.matrix);
                        if (isValidMove(matrix, tetromino.row, tetromino.col)) {
                            tetromino.matrix = matrix;
                        }
                    }

                    // down arrow key (drop)
                    if (e.which === 40) {
                        const row = tetromino.row + 1;

                        if (!isValidMove(tetromino.matrix, row, tetromino.col)) {
                            tetromino.row = row - 1;

                            placeTetromino();
                            return;
                        }

                        tetromino.row = row;
                    }
                });

                // start the game
                rAF = requestAnimationFrame(loop);

            </script>
        </div>

    </body>
</body>

</html>
